\documentclass{llncs}

\usepackage{cite}
\usepackage{xspace}
\usepackage{hyperref}

\newcommand{\jkind}{{\sc JKind}\xspace}
\newcommand{\jkindapi}{{\sc JKindApi}\xspace}
\newcommand{\lustre}{{\sc Lustre}\xspace}

\renewcommand{\paragraph}[1]{\vspace{5pt}\noindent {\bf #1}}

\title{JKind}
\author{Andrew Gacek, John Backes, Mike Whalen, Lucas Wagner, ???}

\begin{document}
\maketitle

\begin{abstract}
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam
  malesuada metus at consequat tempor. Etiam sapien nisi, commodo et
  lobortis a, accumsan non est. Duis odio libero, accumsan quis
  accumsan nec, venenatis at nibh. Etiam in augue viverra, aliquam
  lacus ut, congue arcu. Aenean tempor facilisis est quis viverra.
  Curabitur eu leo ultrices, varius quam id, lobortis libero. Donec in
  vehicula felis.
\end{abstract}

\section{Introduction}

\jkind is an
open-source\footnote{\url{https://github.com/agacek/jkind}} industrial
infinite-state inductive model checker for safety properties. Models
and properties in \jkind are specified in \lustre
\cite{halbwachs1991ieee}, a synchronous data-flow language, using the
theories of linear real and integer arithmetic. \jkind uses
SMT-solvers to prove and falsify multiple properties in parallel.

A distinguishing characteristic of \jkind is its focus on the quality
of results. For a proven property, \jkind provides an inductive
validity core which traces the property back to individual model
elements. For a falsified property, \jkind provides options for
simplifying and generalizing the counterexample in order to highlight
what is causing the property to fail. In industrial applications, we
have found this additional quality of the results to be at least as
important as the primary results.

Another important characteristic of \jkind is that is it designed,
from the start, to be a library which sits underneath user-facing
applications. Written in Java, \jkind runs on all major platforms and
is easily compiled into other Java applications. While \jkind can use
the SMT-solvers {\sc Z3}, {\sc Yices 1}, {\sc Yices 2}, {\sc CVC4}, ,
and {\sc MathSAT}, it is also bundled with the Java-based {\sc
  SMTInterpol}. This means that applications can call out to \jkind
without requiring any other solvers to be natively installed. In
practice, we have found this to be indispensable for deploying
user-facing applications that are powered by model checking.

\section{Functionality and Main Features}

\jkind is structured as several parallel engines that coordinate to
prove properties, mimicking the design of {\sc PKind}
\cite{kahsai2011pdmc}. Some engines are directly responsible for
proving properties, others aid that effort by generating invariants,
and still others are reserved for post-processing of proof or
counterexample results. Each engine can be enabled or disabled
separately based on the user's particular needs. We describe each
engine individually here.

\paragraph{Bounded Model Checking (BMC).} The BMC engine performs a
standard iterative unrolling of the transition relation to find
counterexamples and to serve as the base case of $k$-induction.

\paragraph{$k$-induction.} The $k$-induction engine performs the
inductive step of $k$-induction, possibly using invariants generated by
other engines.

\paragraph{Invariant Generation.} The invariant generation engine uses
a template-based invariant generation technique \cite{kahsai2011nfm}
using its own $k$-induction loop.

\paragraph{Property Directed Reachability (PDR).} The PDR engine
performs property directed reachability \cite{een2011fmcad} using the
implicit abstraction technique \cite{cimatti2014tacas}. Unlike BMC and
$k$-induction, each property is handled separately by a different PDR
sub-engine. Invariants generated as a side-product of PDR are shared
with the $k$-induction process.

\paragraph{Inductive Validity Cores (IVC).} For a proven property, an
inductive validity core is a (hopefully small) subset of \lustre
equations from the input model for which the property still holds
\cite{ghassabani2016fse}. It indicates which portion of the model is
relevant to the proof of the property. The IVC engine uses a heuristic
algorithm to efficiently produce nearly minimal inductive validity
cores. As a side-product, the IVC algorithm also minimizes the set of
invariants used to prove a property and reports back this reduced set.

\paragraph{Advice.} The advice engine is used to save and re-use
results between runs of \jkind. When enabled, a set of invariant from a
previous run of \jkind, so called {\em advice}, is read in and
(hopefully) re-verified. Because advice is re-verified, it does not
need to be completely accurate. In particular, advice from a previous
run of \jkind can be used on a model even if that model is further
modified. Pieces of advice that successfully re-verify are used as
invariants while those that do not are discarded.

\paragraph{Smoothing.} Counterexamples generated from BMC and PDR are
not always easily understood, so as an optional post-processing step
we smooth counterexamples to minimize the number of changes to the
input variables. The smoothing engine uses a {\sc MaxSat} query over
the original BMC-style unrolling of the transition relation combined
with weighted assertions that each input variable does not change on
each step. The {\sc MaxSat} query therefore tries (as best as
possible) to hold all inputs constant while still falsifying the
original property. This engine is only available with solvers that
support {\sc MaxSat} such as Yices and Z3.

\paragraph{Interval Generalization.} Another post-processing step
available for counterexamples is to perform interval generalization
where individual values in a counterexample are replaced by intervals
that still falsify the property. This analysis is done purely through
simulation, without using an SMT-solver. It is useful in showing
that, for example, the value of a variable on a given step only needs
to be positive and its particular value does not matter.

\section{Integration \& Applications}

\jkind is the back-end for a variety of user-facing applications. In
this section, we briefly highlight some of these applications and how
they apply the features of JKind. As \jkind is written in Java, it is
very easy to integrate into other Java applications. Moreover, we
created the \jkindapi package which contains utilities for creating
\lustre specifications, calling \jkind, processing \jkind results,
graphically displaying real-time results, and nicely formatting
counterexamples. Many of the applications in this section make heavy
use of \jkindapi.

\paragraph{Assume Guarantee Reasoning Environment (AGREE). } [John:
please write a couple paragraphs about \jkind in AGREE]

\paragraph{Specification and Analysis of Requirements (SpeAR).}
[Lucas: please write a couple paragraphs about \jkind in Spear]

 \paragraph{SIMPAL (SIMPAL).}
[Lucas: please write a couple paragraphs about \jkind in SIMPAL]

\paragraph{Gryphon?}

\paragraph{Internal tool? MC/DC test gen or flight controls state
  machines?}

\paragraph{Model-based fuzzing?}

\section{Discussion \& Related Work}

\paragraph{Performance.} \jkind is competitive with similar solvers
\cite{champion2016cav}. The most noticeable bottleneck of \jkind is the
start-up time of the Java Virtual Machine (JVM). This cost is
insignificant for most models, but causes decreased performance for
benchmarks consisting of many very small models.

\paragraph{Simulation.} To help users and developers to understand
\lustre specifications, \jkind can compile a \lustre specification
into an Excel-based simulation. The simulation uses the formula and
reference language of Excel to compute, in real-time, the output of the
specification as inputs are entered and manipulated. This spreadsheet
interface to the specification is satisfyingly capable and versatile.

\begin{itemize}
\item JKind excel output for counterexamples
\item Inductive data-types
\item Arrays
\item Uninterpreted functions
\end{itemize}

\bibliography{main}{}
\bibliographystyle{splncs03}

\end{document}




% Local Variables:
% TeX-master: "main.tex"
% End:

%  LocalWords:  BMC PDR IVC MaxSat Yices SpeAR SIMPAL Gryphon UI JVM
%  LocalWords:  JKindApi natively PKind
