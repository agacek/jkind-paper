\documentclass{llncs}

\usepackage{cite}

\title{JKind}
\author{Andrew Gacek, John Backes, Mike Whalen, Lucas Wagner, ???}

\begin{document}
\maketitle

\section{Introduction}

\begin{itemize}
\item Lustre
\item Safety properties / monitors
\item Multi-property
\item SMT-based, Java written, what solvers are supported
\end{itemize}

\section{Functionality and Main Features}

JKind is structured as several parallel engines that coordinate to
prove properties, mimicking the design of pKind \cite{}. Some engines
are directly responsible for proving properties, others aid that
effort by generating invariants, and still others are reserved for
post-processing of proof or counterexample results. Each engine can be
enabled or disabled separately based on the user's particular needs.
We describe each engine individually here.

\paragraph{Bounded Model Checking (BMC).} The BMC engine performs a
standard iterative unrolling of the transition relation to find
counterexamples and to serve as the base case of $k$-induction.

\paragraph{$k$-induction.} The $k$-induction engine performs the
inductive step of $k$-induction, possibly using invariants generated by
other engines.

\paragraph{Invariant Generation.} The invariant generation engine
uses a template-based invariant generation technique \cite{} using its
own $k$-induction loop.

\paragraph{Property Directed Reachability (PDR).} The PDR engine
performs property directed reachability \cite{} using the implicit
abstraction technique \cite{}. Unlike BMC and $k$-induction, each
property is handled separately by a different PDR sub-engine.
Invariants generated as a side-product of PDR are shared with the
$k$-induction process.

\paragraph{Inductive Validity Cores (IVC).} For a proven property, an
inductive validity core is a (hopefully small) subset of Lustre
equations from the input model for which the property still holds
\cite{}. It indicates which portion of the model is relevant to the
proof of the property. The IVC engine uses a heuristic algorithm to
efficiently produce nearly minimal inductive validity cores. As a
side-product, the IVC algorithm also minimizes the set of invariants
used to prove a property and reports back this reduced set.

\paragraph{Advice.} The advice engine is used to save and re-use
results between runs of JKind. When enabled, a set of invariant from a
previous run of JKind, so called {\em advice}, is read in and
(hopefully) re-verified. Because advice is re-verified, it does not
need to be completely accurate. In particular, advice from a previous
run of JKind can be used on a model even if that model is further
modified. Pieces of advice that successfully re-verify are used as
invariants while those that do not are discarded.

\paragraph{Smoothing.} Counterexamples generated from BMC and PDR are
not always easily understood, so as an optional post-processing step
we smooth counterexamples to minimize the number of changes to the
input variables. The smoothing engine uses a {\sc MaxSat} query over
the original BMC-style unrolling of the transition relation combined
with weighted assertions that each input variable does not change on
each step. The {\sc MaxSat} query therefore tries (as best as
possible) to hold all inputs constant while still falsifying the
original property. This engine is only available with solvers that
support {\sc MaxSat} such as Yices and Z3.

\paragraph{Interval Generalization.} Another post-processing step
available for counterexamples is to perform interval generalization
where individual values in a counterexample are replaced by intervals
that still falsify the property. This analysis is done purely through
simulation, without using an SMT-solver. It is useful in showing
that, for example, the value of a variable on a given step only needs
to be positive and its particular value does not matter.

\section{Integration \& Applications}


\paragraph{Assume Guarantee Reasoning Environment (AGREE). } [John:
please write a couple paragraphs about JKind in AGREE]

\paragraph{Specification and Analysis of Requirements (SpeAR).}
[Lucas: please write a couple paragraphs about JKind in Spear]

 \paragraph{SIMPAL (SIMPAL).}
[Lucas: please write a couple paragraphs about JKind in SIMPAL]

\paragraph{Gryphon?}

\paragraph{Internal tool? MC/DC test gen or flight controls state
  machines?}

\paragraph{Model-based fuzzing?}

\section{Discussion \& Related Work}

\begin{itemize}
\item Benchmarks: reference Kind 2 paper and say we are competitive on
  speed and strength but initial start up time due to JVM
\item Relationship to Kind 2~\cite{champion2016cav}
  \begin{itemize}
  \item Both based on PKind
  \item Independently developed from Kind 2, released a couple years earlier
  \item Multi platform due to Java (Windows, Linux, Mac)
  \item JKind has focused on integration from the very beginning. Used
    in AGREE and internal MC/DC test case generation work from day
    one. JKind uses SMTInterpol by default so that it can be packaged
    into other applications and run everywhere with no setup required.
    We also provide JKindApi for things like UI, etc. Maybe
    JKindApi-type discussion belongs in integration and application
    section?
  \end{itemize}
\end{itemize}

\section{Experimental \& Future Work}

\begin{itemize}
\item Inductive data-types
\item Arrays
\item Uninterpreted functions
\end{itemize}

\bibliography{main}{}
\bibliographystyle{splncs03}

\end{document}




% Local Variables:
% TeX-master: "main.tex"
% End:

%  LocalWords:  BMC PDR IVC MaxSat Yices SpeAR SIMPAL Gryphon UI
%  LocalWords:  JKindApi
